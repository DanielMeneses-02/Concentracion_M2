# -*- coding: utf-8 -*-
"""RegresionLineal_Manual.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GQ3_iCze1wKSXIUT0thfNq7AyDgjICDU
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, precision_score, recall_score, f1_score
from sklearn.model_selection import train_test_split


# PREPARACIÓN
df = pd.read_excel("Obesidad.xlsx") # Función para leer el dataset de 'Obesidad.xlsx'
x = np.array(df['Altura']) # 'x' representa la estatura (en metros) de los individuos
y = np.array(df['Peso']) # 'y' representa el peso (en kilogramos) de los individuos
obesidad = np.array(df['Obesidad']) # 'obesidad' indica si un individuo es obeso o no según una clasificación original

x_train, x_test, y_train, y_test, obesidad_train, obesidad_test = train_test_split(x, y, obesidad, test_size=0.3, random_state=42) # Dividir el dataset en entrenamiento (70%) y prueba (30%)

m = 0  # Pendiente inicial de la línea de regresión
b = 0  # Intercepción inicial de la línea de regresión
alpha = 0.001  # Tasa de aprendizaje para el algoritmo de descenso de gradiente
epochs = 100000  # Número máximo de iteraciones
tolerance = 1e-6  # Tolerancia para la convergencia (criterio de parada)
n_train = len(x_train)  # Número de puntos de datos en el conjunto de entrenamiento


# ALGORITMO DE DESCENSO DE GRADIENTE PARA ENCONTRAR LA MEJOR LÍNEA DE REGRESIÓN EN LOS DATOS DE ENTRENAIENTO
for epoch in range(epochs):
    hxi = m * x_train + b # Calcular las predicciones usando la fórmula de la línea de regresión: hxi = m * x + b
    error = hxi - y_train # Calcular los errores entre las predicciones y los valores reales de 'y'
    costo_m = (1/n_train) * sum(error * x_train) # Calcular el gradiente para ajustar 'm' y 'b'
    costo_b = (1/n_train) * sum(error) # Actualizar los valores de 'm' y 'b' utilizando el gradiente y la tasa de aprendizaje 'alpha'
    m -= alpha * costo_m
    b -= alpha * costo_b

    # Verificar si el algoritmo ha convergido. La convergencia se logra si las actualizaciones son menores que 'tolerance'
    if abs(alpha * costo_m) < tolerance and abs(alpha * costo_b) < tolerance:
        print("La convergencia ha sido alcanzada.")
        break

    # Imprimir los valores actuales de 'm' y 'b' cada 500 iteraciones para seguimiento
    if epoch % 500 == 0:
        print(f"Iteración {epoch+1}, m: {m}, b: {b}")

print("\n---------RESULTADOS FINALES---------") # Resultados finales para 'm' y 'b' después del entrenamiento
print(f"Pendiente (m): {m}")
print(f"Intercepción (b): {b}\n")


# RESULTADOS DE ENTRENAMIENTO
# Clasificación en el conjunto de entrenamiento
# Si un punto de datos tiene un peso real mayor que la predicción (por encima de la línea), se clasifica como 'Si', de lo contrario, se clasifica como 'No'
predicciones_train = m * x_train + b
clasificacion_obesidad_train = np.where(y_train > predicciones_train, 'Si', 'No')

# Generar la matriz de confusión para los datos de entrenamiento
cm_train = confusion_matrix(obesidad_train, clasificacion_obesidad_train, labels=['Si', 'No'])
disp_train = ConfusionMatrixDisplay(confusion_matrix=cm_train, display_labels=['Obesidad', 'No Obesidad'])

# Mostrar la matriz de confusión para los datos de entrenamiento
disp_train.plot(cmap=plt.cm.Blues)
plt.title("Matriz de Confusión - Entrenamiento")
plt.show()

# Calcular precisión, recall y F1-score para la clasificación basada en la línea de regresión en el conjunto de entrenamiento
precision = precision_score(obesidad_train, clasificacion_obesidad_train, pos_label='Si')
recall = recall_score(obesidad_train, clasificacion_obesidad_train, pos_label='Si')
f1 = f1_score(obesidad_train, clasificacion_obesidad_train, pos_label='Si')

# Mostrar los resultados de las métricas de evaluación en el conjunto de entrenamiento
print(f"Precisión: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f} \n")

# Graficar los puntos de datos de entrenamiento junto con la línea de regresión
plt.figure(figsize=(10, 6))

# Puntos de datos clasificados originalmente como obesos y no obesos
plt.scatter(x_train[obesidad_train == 'Si'], y_train[obesidad_train == 'Si'], color='blue', label='Obesos (Original)')
plt.scatter(x_train[obesidad_train == 'No'], y_train[obesidad_train == 'No'], color='orange', label='No Obesos (Original)')

# Puntos de datos clasificados según la nueva clasificación basada en la línea de regresión
plt.scatter(x_train[clasificacion_obesidad_train == 'Si'], y_train[clasificacion_obesidad_train == 'Si'], color='white', marker='x', label='Obesos (Clasificación)')
plt.scatter(x_train[clasificacion_obesidad_train == 'No'], y_train[clasificacion_obesidad_train == 'No'], color='black', marker='x', label='No Obesos (Clasificación)')

# Línea de regresión ajustada
plt.plot(x_train, predicciones_train, color='red', label='Línea de regresión')

# Etiquetas y título del gráfico
plt.xlabel('Altura')
plt.ylabel('Peso')
plt.title('Regresión Lineal con Clasificación Basada en la Línea de Regresión - Entrenamiento')
plt.legend()
plt.grid(True)
plt.show()

# RESULTADOS DE PRUEBA
# Probar el modelo en el conjunto de prueba
predicciones_test = m * x_test + b
clasificacion_obesidad_test = np.where(y_test > predicciones_test, 'Si', 'No')

# Generar la matriz de confusión para los datos de prueba
cm_test = confusion_matrix(obesidad_test, clasificacion_obesidad_test, labels=['Si', 'No'])
disp_test = ConfusionMatrixDisplay(confusion_matrix=cm_test, display_labels=['Obesidad', 'No Obesidad'])

# Mostrar la matriz de confusión para los datos de prueba
disp_test.plot(cmap=plt.cm.Blues)
plt.title("Matriz de Confusión - Prueba")
plt.show()

# Calcular precisión, recall y F1-score para la clasificación basada en la línea de regresión en el conjunto de prueba
precision = precision_score(obesidad_test, clasificacion_obesidad_test, pos_label='Si')
recall = recall_score(obesidad_test, clasificacion_obesidad_test, pos_label='Si')
f1 = f1_score(obesidad_test, clasificacion_obesidad_test, pos_label='Si')

# Mostrar los resultados de las métricas de evaluación en el conjunto de prueba
print(f"Precisión: {precision:.2f}")
print(f"Recall: {recall:.2f}")
print(f"F1 Score: {f1:.2f}\n")

# Graficar los puntos de datos junto con la línea de regresión
plt.figure(figsize=(10, 6))

# Puntos de datos clasificados originalmente como obesos y no obesos
plt.scatter(x_test[obesidad_test == 'Si'], y_test[obesidad_test == 'Si'], color='blue', label='Obesos (Original)')
plt.scatter(x_test[obesidad_test == 'No'], y_test[obesidad_test == 'No'], color='orange', label='No Obesos (Original)')

# Puntos de datos clasificados según la nueva clasificación basada en la línea de regresión
plt.scatter(x_test[clasificacion_obesidad_test == 'Si'], y_test[clasificacion_obesidad_test == 'Si'], color='white', marker='x', label='Obesos (Clasificación)')
plt.scatter(x_test[clasificacion_obesidad_test == 'No'], y_test[clasificacion_obesidad_test == 'No'], color='black', marker='x', label='No Obesos (Clasificación)')

# Línea de regresión ajustada
plt.plot(x_test, predicciones_test, color='red', label='Línea de regresión')

# Etiquetas y título del gráfico
plt.xlabel('Altura')
plt.ylabel('Peso')
plt.title('Regresión Lineal con Clasificación Basada en la Línea de Regresión - Prueba')
plt.legend()
plt.grid(True)
plt.show()